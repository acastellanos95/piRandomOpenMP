<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
<link rel="stylesheet" href="file:////home/andre/.vscode/extensions/goessner.mdmath-2.7.4/themes/default/style.css">

</head>
<body class="markdown-body">
<h1 id="proyecto-cc3a1lculo-paralelo-de-pi-usando-la-funcic3b3n-ran2-con-openmp">Proyecto: Cálculo paralelo de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> usando la función <code>ran2</code> con OpenMP</h1>
<h2 id="cinvestav---departamento-de-computacic3b3n">CINVESTAV - Departamento de computación</h2>
<h3 id="autor-andrc3a9-fabic3a1n-castellanos-aldama">Autor: André Fabián Castellanos Aldama</h3>
<h3 id="1-de-diciembre-del-2021">1 de Diciembre del 2021</h3>
<div  ></div>
<br>
<p><strong>El código lo puede encontrar en el siguiente <a href="https://github.com/acastellanos95/piRandomOpenMP">link</a></strong></p>
<h3 id="objetivo">Objetivo</h3>
<ol>
<li>Calcular secuencialmente <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> con <code>ran2</code>.</li>
<li>Implementar <code>ran2</code> como la clase <code>Ran2T</code> para usar una solución paralela.</li>
<li>Calcular con <code>Ran2T</code> el valor de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq>.</li>
<li>Presentar resultados y tiempos de ejecución.</li>
</ol>
<h3 id="problema">Problema</h3>
<p>Actualmente se conocen muchas maneras de calcular <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> unas más rápidas que otras y algunos que otorgan mayor exactitud por cada iteración. Sin embargo, para este proyecto utilizaremos el método Montecarlo para calcular <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq>.</p>
<h3 id="mc3a9todo-montecarlo">Método Montecarlo</h3>
<p>Las simulaciones Montecarlo son algoritmos o experimentos que se basan en el muestreo de números aleatorios. Este experimento se repite un grán número de veces para estimar algo que podría ser estimado deterministicamente como <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq>.</p>
<h4 id="cc3a1lculo-de-pi">Cálculo de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq></h4>
<p>Sabemos como calcular deterministicamente el aŕea de un cuadrado y un círculo, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>l</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">A=l^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> y <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">A=\pi r^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> respectivamente. Supongamos el cuadrado unitario que encierra un cuarto del área del círculo unitario en el primer cuadrante como se muestra:</p>
<p><img src="Montecarlocuadrcirc.png" alt="Círculo dentro de cuadrado!" title="CirculoCuadrado" class="loading" id="image-hash-911032108" data-src="Montecarlocuadrcirc.png"></p>
<p><em>Figura 1. Cuadrado unitario que encierra un cuarto del círculo unitario en el primer cuadrante.</em></p>
<p>Ahora bien, si aleatoriamente pusieramos puntos dentro de este cuadrado y además conforme el número de estos puntos sea mayor, estaríamos cubriendo el área del cuadrado y el cuarto del área del círculo unitario. Encontraríamos la relación siguiente:</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mover accent="true"><mtext>A</mtext><mo>ˊ</mo></mover><mtext>rea c</mtext><mover accent="true"><mtext>ı</mtext><mo>ˊ</mo></mover><mtext>rculo</mtext></mrow><mrow><mover accent="true"><mtext>A</mtext><mo>ˊ</mo></mover><mtext>rea cuadrado</mtext></mrow></mfrac><mo>=</mo><mfrac><mrow><mtext>N</mtext><mover accent="true"><mtext>u</mtext><mo>ˊ</mo></mover><mtext>mero puntos dentro de fracci</mtext><mover accent="true"><mtext>o</mtext><mo>ˊ</mo></mover><mtext>n del c</mtext><mover accent="true"><mtext>ı</mtext><mo>ˊ</mo></mover><mtext>rculo</mtext></mrow><mrow><mtext>N</mtext><mover accent="true"><mtext>u</mtext><mo>ˊ</mo></mover><mtext>mero puntos en cuadrado</mtext></mrow></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mrow><mi>π</mi><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><mrow><mn>1</mn><mo>⋅</mo><mn>1</mn></mrow></mfrac><mspace linebreak="newline"></mspace><mo>↔</mo><mi>π</mi><mo>=</mo><mn>4</mn><mo>⋅</mo><mfrac><mrow><mtext>N</mtext><mover accent="true"><mtext>u</mtext><mo>ˊ</mo></mover><mtext>mero puntos dentro de fracci</mtext><mover accent="true"><mtext>o</mtext><mo>ˊ</mo></mover><mtext>n del c</mtext><mover accent="true"><mtext>ı</mtext><mo>ˊ</mo></mover><mtext>rculo</mtext></mrow><mrow><mtext>N</mtext><mover accent="true"><mtext>u</mtext><mo>ˊ</mo></mover><mtext>mero puntos en cuadrado</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">
  \frac{\text{Área círculo}}{\text{Área cuadrado}} = \frac{\text{Número puntos dentro de fracción del círculo}}{\text{Número puntos en cuadrado}}\\
  =\frac{\pi \cdot (1)^2 / 4}{1\cdot 1}\\
  \leftrightarrow \pi = 4 \cdot \frac{\text{Número puntos dentro de fracción del círculo}}{\text{Número puntos en cuadrado}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.46054em;vertical-align:-0.8367699999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.62377em;"><span style="top:-2.16323em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">A</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">rea cuadrado</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">A</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">rea c</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord latin_fallback">ı</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">rculo</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8367699999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">N</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">mero puntos en cuadrado</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">N</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">mero puntos dentro de fracci</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">o</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">n del c</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord latin_fallback">ı</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">rculo</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">N</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">mero puntos en cuadrado</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">N</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">mero puntos dentro de fracci</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">o</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">n del c</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord latin_fallback">ı</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord">rculo</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section></math>
<h3 id="implementacic3b3n-secuencial-usando-ran2">Implementación secuencial usando <code>ran2</code></h3>
<p>La implementación del cálculo de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> es como sigue:</p>
<pre><code class="code-line language-C++"><div><span class="hljs-comment">/* Programa Secuencial: no me gustaría que estuviera aquí la función pero es bueno para enseñar la diferencias*/</span>
<span class="hljs-keyword">double</span> t_seq_init = omp_get_wtime();
<span class="hljs-keyword">long</span> inp = <span class="hljs-number">-1</span>;
<span class="hljs-comment">/*Calculate pi*/</span>
<span class="hljs-keyword">long</span> eb = <span class="hljs-number">0</span>;
<span class="hljs-keyword">long</span> te = num_iterations;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; te; ++i) {
  <span class="hljs-keyword">float</span> x = ran2(&amp;inp);
  <span class="hljs-keyword">float</span> y = ran2(&amp;inp);
  <span class="hljs-keyword">if</span>((x*x+y*y) &lt;= <span class="hljs-number">1.0</span>)
    eb++;
}
<span class="hljs-keyword">double</span> t_seq_fin = omp_get_wtime();

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;pi es: &quot;</span> &lt;&lt; (<span class="hljs-keyword">float</span>) eb/ (<span class="hljs-keyword">float</span>) te*<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;tiempo secuencial es: &quot;</span> &lt;&lt; t_seq_fin - t_seq_init &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</div></code></pre>
<p><code>inp</code> es igual a <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></eq> porque según en el libro numerical recipes in C se pide que se inicialice con un número negativo y después solo se siga pasando la misma referencia de este número. Lamentablemente como lo comenta el libro, para el mismo número negativo de inicialización generará la misma secuencia de números.</p>
<h3 id="implementacic3b3n-de-la-clase-ran2">Implementación de la clase <code>Ran2</code></h3>
<p>Para poder hacer una implementación del algoritmo de manera paralela necesitamos que cada hilo tenga su instancia de la función <code>ran2</code> con un número negativo diferente para inicializar. Para eso lo implementamos como sigue:</p>
<pre><code class="code-line language-C++"><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>{</span>
  <span class="hljs-keyword">long</span> idum;
  <span class="hljs-keyword">long</span> idum2;
  <span class="hljs-keyword">long</span> iy;
  <span class="hljs-keyword">long</span> iv[<span class="hljs-number">32</span>];
} ran2NR;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ran2</span> {</span>
  ran2NR _r;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> _id;
 <span class="hljs-keyword">public</span>:
  Ran2() = <span class="hljs-keyword">default</span>;
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Ran2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inum_init, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ran2T</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Ran2::ran2T</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> j;
  <span class="hljs-keyword">long</span> k;
  <span class="hljs-keyword">float</span> temp;

  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;_r.idum &lt;= <span class="hljs-number">0</span>){
    <span class="hljs-keyword">if</span> (-(<span class="hljs-keyword">this</span>-&gt;_r.idum) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">this</span>-&gt;_r.idum=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>-&gt;_r.idum = -(<span class="hljs-keyword">this</span>-&gt;_r.idum);
    <span class="hljs-keyword">this</span>-&gt;_r.idum2 = (<span class="hljs-keyword">this</span>-&gt;_r.idum);
    <span class="hljs-keyword">for</span> (j = NTAB+<span class="hljs-number">7</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
      k = (<span class="hljs-keyword">this</span>-&gt;_r.idum)/IQ1;
      <span class="hljs-keyword">this</span>-&gt;_r.idum = IA1*(<span class="hljs-keyword">this</span>-&gt;_r.idum-k*IQ1)-k*IR1;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_r.idum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>-&gt;_r.idum += IM1;
      <span class="hljs-keyword">if</span> (j &lt; NTAB) <span class="hljs-keyword">this</span>-&gt;_r.iv[j] = <span class="hljs-keyword">this</span>-&gt;_r.idum;
    }
    <span class="hljs-keyword">this</span>-&gt;_r.iy = <span class="hljs-keyword">this</span>-&gt;_r.iv[<span class="hljs-number">0</span>];
  }

  k = (<span class="hljs-keyword">this</span>-&gt;_r.idum)/IQ1;
  <span class="hljs-keyword">this</span>-&gt;_r.idum = IA1*(<span class="hljs-keyword">this</span>-&gt;_r.idum-k*IQ1)-k*IR1;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_r.idum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>-&gt;_r.idum += IM1;
  k = <span class="hljs-keyword">this</span>-&gt;_r.idum2/IQ2;
  <span class="hljs-keyword">this</span>-&gt;_r.idum2 = IA2*(<span class="hljs-keyword">this</span>-&gt;_r.idum2-k*IQ2)-k*IR2;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_r.idum2 &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>-&gt;_r.idum2 += IM2;
  j = <span class="hljs-keyword">this</span>-&gt;_r.iy/NDIV;
  <span class="hljs-keyword">this</span>-&gt;_r.iy = <span class="hljs-keyword">this</span>-&gt;_r.iv[j]-<span class="hljs-keyword">this</span>-&gt;_r.idum2;
  <span class="hljs-keyword">this</span>-&gt;_r.iv[j] = <span class="hljs-keyword">this</span>-&gt;_r.idum;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_r.iy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">this</span>-&gt;_r.iy += IMM1;

  <span class="hljs-keyword">if</span> ((temp=AM*<span class="hljs-keyword">this</span>-&gt;_r.iy) &gt; RNMX) <span class="hljs-keyword">return</span> RNMX;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> temp;
}

Ran2::Ran2(<span class="hljs-keyword">int</span> idum_init, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id) {
  <span class="hljs-keyword">this</span>-&gt;_r.idum = idum_init;
  <span class="hljs-keyword">this</span>-&gt;_id = id;
}
</div></code></pre>
<p>Esta clase nos permitirá que cada hilo tenga su instancia de <code>Ran2</code> con su respectiva función <code>ran2T</code>.</p>
<h3 id="implementacic3b3n-de-la-solucic3b3n-paralela">Implementación de la solución paralela</h3>
<p>Representa un reto el que cada hilo tenga una instancia de <code>ran2</code> con su respectiva función <code>ran2T</code> con diferentes números negativos. Esto podemos solucionarlo haciendo un arreglo de instancias de <code>ran2T</code> con número de inicialización asociado al hilo donde corre pero negativo para que cada hilo tenga una secuencia de números diferentes.</p>
<p>Además para guardar el número de puntos en el círculo debemos usar una reducción, este no es necesario que por hilo tenga su propio contador ya que comparten para la solución final el mismo denominador <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>num puntos circulo hilo 1</mtext><mi mathvariant="normal">/</mi><mtext>num puntos creados</mtext><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mtext>num puntos circulo hilo n</mtext><mi mathvariant="normal">/</mi><mtext>num puntos creados</mtext></mrow><annotation encoding="application/x-tex">\text{num puntos circulo hilo 1}/\text{num puntos creados}+...+\text{num puntos circulo hilo n}/\text{num puntos creados}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">num puntos circulo hilo 1</span></span><span class="mord">/</span><span class="mord text"><span class="mord">num puntos creados</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">num puntos circulo hilo n</span></span><span class="mord">/</span><span class="mord text"><span class="mord">num puntos creados</span></span></span></span></span></eq>.</p>
<p>La implementación es como sigue:</p>
<pre><code class="code-line language-C++"><div><span class="hljs-comment">/*Crear vector de clase Ran2 e inicializar*/</span>
  <span class="hljs-keyword">double</span> t_seq_par_init = omp_get_wtime();
  <span class="hljs-keyword">auto</span> *rans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Ran2&gt;();
  <span class="hljs-keyword">int</span> num_threads = omp_get_max_threads();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) {
    rans-&gt;emplace_back(Ran2(-((<span class="hljs-keyword">int</span>) i+<span class="hljs-number">1</span>), i));
  }

  <span class="hljs-comment">/*Imprimir tamaño de vector*/</span>
<span class="hljs-comment">//  std::cout &lt;&lt; &quot;tamaño de vector después de inicialización: &quot; &lt;&lt; rans-&gt;size() &lt;&lt; std::endl;</span>

  <span class="hljs-comment">/*Calculo de pi*/</span>

  <span class="hljs-keyword">int</span> ebT=<span class="hljs-number">0</span>;

  <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for default(none) shared(rans, num_iterations) reduction(+:ebT)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_iterations; ++i) {
    <span class="hljs-comment">/*Debug printing*/</span>
<span class="hljs-comment">//    printf(&quot;indice: %d\t&quot;, i);</span>
<span class="hljs-comment">//    printf(&quot;thread: %d, ran2=%f\n&quot;,thread_num, rans-&gt;at(thread_num).ran2T());</span>

    <span class="hljs-keyword">int</span> thread_num = omp_get_thread_num();
    <span class="hljs-keyword">float</span> x = rans-&gt;at(thread_num).ran2T();
    <span class="hljs-keyword">float</span> y = rans-&gt;at(thread_num).ran2T();
    <span class="hljs-keyword">if</span>((x*x+y*y) &lt;= <span class="hljs-number">1.0</span>)
      ebT++;
  }

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;pi es: &quot;</span> &lt;&lt; (<span class="hljs-keyword">float</span>) ebT/ (<span class="hljs-keyword">float</span>) num_iterations*<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

  <span class="hljs-keyword">double</span> t_seq_par_fin = omp_get_wtime();
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;tiempo paralelo es: &quot;</span> &lt;&lt; t_seq_par_fin - t_seq_par_init &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</div></code></pre>
<h3 id="resultados">Resultados</h3>
<h4 id="prueba">Prueba</h4>
<p>En el ejemplo secuencial el valor de inicio es <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></eq> que es como se inicializa <code>Ran2</code> para el hilo 0. ESto significa que si ejecutamos para un solo hilo. La solución secuencial y la paralela deberían coincidir los resultados. Ejecutando para un solo hilo y los siguientes número de puntos 1000, 10000, 100000, 1000000, 10000000.</p>
<pre><code class="code-line language-bash"><div>pi secuencial es: 3.104, tiempo secuencial es: 0.000148441s, pi paralelo es: 3.104, tiempo paralelo es: 0.000375351s
pi secuencial es: 3.1524, tiempo secuencial es: 0.000661592s, pi paralelo es: 3.1524, tiempo paralelo es: 0.00110507s
pi secuencial es: 3.14636, tiempo secuencial es: 0.0066691s, pi paralelo es: 3.14636, tiempo paralelo es: 0.009459s
pi secuencial es: 3.14155, tiempo secuencial es: 0.0533191s, pi paralelo es: 3.14155, tiempo paralelo es: 0.0656643s
pi secuencial es: 3.14173, tiempo secuencial es: 0.429616s, pi paralelo es: 3.14173, tiempo paralelo es: 0.655632s
</div></code></pre>
<p>Observamos que obtenemos el mismo valor de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> en todos los casos como esparabamos. Otro dato interesante es que podemos ver como el overhead de usar el framework OpenMP hace que en el caso de la ejecución de un hilo es más tardado que la solución secuencial.</p>
<h4 id="comparaciones">Comparaciones</h4>
<p>Se ejecutó para los número de puntos 100000, 1000000 y 10000000 con 2,4,6,8,10,12 hilos. A continuación se presentan la gráfica con los resultados.</p>
<p><img src="seqtime.png" alt="Resultado1!" title="Resultado1" class="loading" id="image-hash--571919970" data-src="seqtime.png"></p>
<p><em>Figura 2. Iteraciones contra tiempo en segundos de la solución secuencial para el número de puntos generados 100000, 1000000 y 10000000. Aunque no se observan los puntos claramente, queda demostrado que la complejidad del problema secuencial es lineal.</em></p>
<p><img src="partime.png" alt="Resultado2!" title="Resultado2" class="loading" id="image-hash--497433632" data-src="partime.png"></p>
<p><em>Figura 3. Número de hilos contra tiempo de ejecución en segundos con su curva respectivamente etiquetada con el número de puntos generados. Podemos notar como el tiempo de ejecución se reduce con cada aumento de hilos de 2 a 12.</em></p>
<p><img src="pivalues.png" alt="Resultado3!" title="Resultado3" class="loading" id="image-hash--1030122433" data-src="pivalues.png"></p>
<p><em>Figura 4. Valor de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> contra el número de hilos etiquetados por el número de puntos creados. Se puede observar que en general a menor número de puntos creados menos es la precisión del valor de <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> encontrado.</em></p>
<h4 id="aceleracic3b3n">Aceleración</h4>
<p><img src="acc.png" alt="Resultado4!" title="Resultado4" class="loading" id="image-hash-445408115" data-src="acc.png"></p>
<p><em>Figura 5. Aceleración contra número de hilos etiquetados por el número de puntos creados. Se observa que en general conforme aumentamos el número de hilos usados la acelaración crece como se esperaba.</em></p>
<h3 id="conclusiones">Conclusiones</h3>
<p>Los resultados encontrados apuntan a una buena implementación de la solución tanto secuencial como paralela. Se redujo el tiempo de ejecución usando paralelismo que es más notorio cuando se crean más número de puntos.</p>
<p>Con respecto a la aceleracíon, encontramos lo que se esperaba excepto porque la aceleración para 100000 puntos creados con 2 hilos es mayor que el de 4. Esto podría deberse a que el tiempo por overhead fue mayor que el tiempo de ejecución secuencial por el hecho de haber usado pocos puntos.</p>
<p>Sería interesante para un mayor número de puntos de tal manera que encontraramos tiempos de ejecución de minutos, sin embargo, con el número de puntos resulta suficiente para presentar resultados que en general son como esperabamos.</p>

</body>
</html>